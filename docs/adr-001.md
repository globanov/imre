# ADR-001: Event-Driven Workload Aggregation

## Status
Accepted (MVP)

## Context
We need to update weekly workload totals when a shift is created.

## Decision
Use **synchronous event processing** within the same HTTP request:
- No message broker (Redis/Kafka)
- No separate worker process
- Event handler (`handle_shift_created`) called directly from API view
- Full operation is atomic (DB transaction includes aggregate update)

## Rationale
- **Simplicity**: no operational complexity (no queues, no retries, no dead-letter topics)
- **Consistency**: aggregates are always up-to-date after API response
- **Debuggability**: single call stack, easy logging and testing
- **MVP focus**: async can be added later if throughput becomes an issue

## Consequences
- HTTP request latency includes aggregation time (~1–5 ms)
- No built-in retry for failed updates (but failures are rare in sync flow)
- Future scalability requires extracting worker — low effort due to clean architecture

## Alignment
- ✅ Matches `README.md`: "synchronous processing, no message broker"
- ✅ Matches code: `publish(event)` → direct call to `handle_shift_created`
- ✅ No Redis, no Celery, no FastAPI
